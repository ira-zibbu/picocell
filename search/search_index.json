{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"picocell picocell is a protein-language model guided simulation of cellular evolution. picocell was made for BCH394P in Spring 2025 at UT Austin. To get started: Read an introduction to the project Look at what powers picocell under the hood Give it a spin yourself See some results of simulations Peek the source code Evolution is overrated! I've been doing just fine without it. Now tell me more about this 'machine learning' thing you say you are doing..","title":"Home"},{"location":"#picocell","text":"picocell is a protein-language model guided simulation of cellular evolution. picocell was made for BCH394P in Spring 2025 at UT Austin. To get started: Read an introduction to the project Look at what powers picocell under the hood Give it a spin yourself See some results of simulations Peek the source code Evolution is overrated! I've been doing just fine without it. Now tell me more about this 'machine learning' thing you say you are doing..","title":"picocell"},{"location":"code/","text":"Code Set up Begin by cloning this repository git clone https://github.com/ira-zibbu/picocell.git Create the picocell conda environment cd picocell conda env create -f picocell.yaml This additional submodule is also required cd picocell/src/ git submodule add https://github.com/ira-zibbu/EvolvePro Create the necessary environments cd EvolvePro conda env create -f environment.yml sh setup_plm.sh Training the regressor The first part requires us to a build a regression model that maps the embeddings of the proteins to their actvitiy or fitness. We will use a deep mutational scanning dataset of cas12f protein to train the regressor. First, we need to generate a FASTA file of all possible single amino acid substitution variants of the wildtype cas12a sequence. conda activate evolvepro ./trial_run.py --file ../../run/01_wildtype/cas12f_WT.fasta --output ../../run/02_mutant_fasta/cas12f_aa_mutants.fasta conda deactivate evolvepro With all the mutants generated, we can now use a PLM to generated embeddings. We will use ESM1 (650M) model, and average the embeddings across all of the amino acids. conda activate plm python3 evolvepro/plm/esm/extract.py esm1b_t33_650M_UR50S ../../run/02_mutant_fasta/cas12f_aa_mutants.fasta ../../run/04_embeddings/casf21f_esm1b_t33_650M_UR50S --toks_per_batch 512 --include mean --concatenate_dir ../../run/04_embeddings conda deactivate plm Using these embeddings, and the deep mutational scanning dataset, we can train a random forest regressor to learn to map the embeddings to the activity of the protein (which in this case is also the fitness of the protein. conda activate picocell src/scripts/train_RF.py --dms run/03_dms_data/DMS_AsCas12f_preprocessed.xlsx --embeddings run/04_embeddings/cas12f_aa_mutants_esm1b_t33_650M_UR50S.csv --model_path run/05_rf_model/rf_model.pkl conda deactivate picocell This step can take a few hours on a personal computer. This outputs a pickle object of the model in run/05_rf_model . Running picocell Picocell needs its own conda environment conda activate picocell Here is the general usage for picocell: usage: picocell.py [-h] [--output OUTPUT] [--no_selection] [--drift DRIFT] [--generations GENERATIONS] [--mutation_rate MUTATION_RATE] Picocell.py, a model of evolution options: -h, --help show this help message and exit --output OUTPUT Path to output the results of the run --no_selection Disable natural selection --drift DRIFT Set genetic drift level (0-1). --generations GENERATIONS Number of generations to run the simulation for --mutation_rate MUTATION_RATE Per base per generation mutation rate (float) The output is a csv file, with the following fields: Cell ID DNA sequence Amino acid sequence Fitness Mutation rate Generation (aka when was this cell born) Death (aka when did this cell die) Here's is an example usage and output: src/scripts/picocell.py --output run/06_output/run_2.csv --drift 0 --generations 20 --mutation_rate 0.001 This run has no genetic drift at play, goes for 20 generations and uses a fairly high mutation rate. Remember, cells divide exponentially, so make sure you limit the total number of generations. ================================ _ _ _ (_) | | | _ __ _ ___ ___ __ _ ___| | | | '_ || |/ __/ _ | / __/ _ | | | | |_) | | (_| (_) | (_| __/ | | | .__/|_||___|___/ |___|___|_|_| | | |_| ================================ Picocell is a PLM-based model of cellular evolution Initial parameters (loading)... Natural selection present? True Genetic drift level? 0 Number of starting cells: 1 Information about starting cells: Cell #1, with fitness 1.0 and mutation rate 0.01 Starting simulation... generation count is 1 cell #1 fails to reproduce generation count is 2 cell #1 fails to reproduce generation count is 3 Time for cell #1 to reproduce! mutant child with non-synonymous substitution ['F48Y', 'K96R', 'D100V', 'I109N', 'I166S', 'L337R'] Subprocess extraction completed successfully. Size of embeddings is (1, 1280) generation count is 4 cell #1 fails to reproduce cell #2 fails to reproduce generation count is 5 cell #1 fails to reproduce cell #2 fails to reproduce generation count is 6 cell #1 fails to reproduce Time for cell #2 to reproduce! Lethal mutation! This child cell is killed generation count is 7 Time for cell #1 to reproduce! mutant child with non-synonymous substitution ['A172S', 'N296D', 'R335H', 'A400S', 'I416S'] Subprocess extraction completed successfully. Size of embeddings is (1, 1280) cell #2 fails to reproduce cell #3 fails to reproduce","title":"Code"},{"location":"code/#code","text":"","title":"Code"},{"location":"code/#set-up","text":"Begin by cloning this repository git clone https://github.com/ira-zibbu/picocell.git Create the picocell conda environment cd picocell conda env create -f picocell.yaml This additional submodule is also required cd picocell/src/ git submodule add https://github.com/ira-zibbu/EvolvePro Create the necessary environments cd EvolvePro conda env create -f environment.yml sh setup_plm.sh","title":"Set up"},{"location":"code/#training-the-regressor","text":"The first part requires us to a build a regression model that maps the embeddings of the proteins to their actvitiy or fitness. We will use a deep mutational scanning dataset of cas12f protein to train the regressor. First, we need to generate a FASTA file of all possible single amino acid substitution variants of the wildtype cas12a sequence. conda activate evolvepro ./trial_run.py --file ../../run/01_wildtype/cas12f_WT.fasta --output ../../run/02_mutant_fasta/cas12f_aa_mutants.fasta conda deactivate evolvepro With all the mutants generated, we can now use a PLM to generated embeddings. We will use ESM1 (650M) model, and average the embeddings across all of the amino acids. conda activate plm python3 evolvepro/plm/esm/extract.py esm1b_t33_650M_UR50S ../../run/02_mutant_fasta/cas12f_aa_mutants.fasta ../../run/04_embeddings/casf21f_esm1b_t33_650M_UR50S --toks_per_batch 512 --include mean --concatenate_dir ../../run/04_embeddings conda deactivate plm Using these embeddings, and the deep mutational scanning dataset, we can train a random forest regressor to learn to map the embeddings to the activity of the protein (which in this case is also the fitness of the protein. conda activate picocell src/scripts/train_RF.py --dms run/03_dms_data/DMS_AsCas12f_preprocessed.xlsx --embeddings run/04_embeddings/cas12f_aa_mutants_esm1b_t33_650M_UR50S.csv --model_path run/05_rf_model/rf_model.pkl conda deactivate picocell This step can take a few hours on a personal computer. This outputs a pickle object of the model in run/05_rf_model .","title":"Training the regressor"},{"location":"code/#running-picocell","text":"Picocell needs its own conda environment conda activate picocell Here is the general usage for picocell: usage: picocell.py [-h] [--output OUTPUT] [--no_selection] [--drift DRIFT] [--generations GENERATIONS] [--mutation_rate MUTATION_RATE] Picocell.py, a model of evolution options: -h, --help show this help message and exit --output OUTPUT Path to output the results of the run --no_selection Disable natural selection --drift DRIFT Set genetic drift level (0-1). --generations GENERATIONS Number of generations to run the simulation for --mutation_rate MUTATION_RATE Per base per generation mutation rate (float) The output is a csv file, with the following fields: Cell ID DNA sequence Amino acid sequence Fitness Mutation rate Generation (aka when was this cell born) Death (aka when did this cell die) Here's is an example usage and output: src/scripts/picocell.py --output run/06_output/run_2.csv --drift 0 --generations 20 --mutation_rate 0.001 This run has no genetic drift at play, goes for 20 generations and uses a fairly high mutation rate. Remember, cells divide exponentially, so make sure you limit the total number of generations. ================================ _ _ _ (_) | | | _ __ _ ___ ___ __ _ ___| | | | '_ || |/ __/ _ | / __/ _ | | | | |_) | | (_| (_) | (_| __/ | | | .__/|_||___|___/ |___|___|_|_| | | |_| ================================ Picocell is a PLM-based model of cellular evolution Initial parameters (loading)... Natural selection present? True Genetic drift level? 0 Number of starting cells: 1 Information about starting cells: Cell #1, with fitness 1.0 and mutation rate 0.01 Starting simulation... generation count is 1 cell #1 fails to reproduce generation count is 2 cell #1 fails to reproduce generation count is 3 Time for cell #1 to reproduce! mutant child with non-synonymous substitution ['F48Y', 'K96R', 'D100V', 'I109N', 'I166S', 'L337R'] Subprocess extraction completed successfully. Size of embeddings is (1, 1280) generation count is 4 cell #1 fails to reproduce cell #2 fails to reproduce generation count is 5 cell #1 fails to reproduce cell #2 fails to reproduce generation count is 6 cell #1 fails to reproduce Time for cell #2 to reproduce! Lethal mutation! This child cell is killed generation count is 7 Time for cell #1 to reproduce! mutant child with non-synonymous substitution ['A172S', 'N296D', 'R335H', 'A400S', 'I416S'] Subprocess extraction completed successfully. Size of embeddings is (1, 1280) cell #2 fails to reproduce cell #3 fails to reproduce","title":"Running picocell"},{"location":"introduction/","text":"Introduction Physicists have spent a lot of time looking for a grand theory to unify the discipline; biologists were gifted one with the theory of evolution in the 19th century. I don\u2019t think evolution alone has the explanatory power to describe all biological processes, but rather that evolution is the framework within which all of biology is contextualised. It is omnipresent, from viruses to elephants to mosses, and it is causally responsible for the 'endless forms most beautiful and most wonderful'. Evolution is a complex phenomenon, and often manifests patterns that seem to be in conflict with each other. Evolution generates both convergence and divergence in form and function. Sometimes, it is highly predictable and repeatable; other times it is idiosyncratic. Inspite of this, evolution can be broken down to a few key components, and these components are best explained through the metaphor of the 'fitness landscape'. The XY plane is a low-dimensional representation of 'genotypic space', where each point in the plane represents a unique set of alleles or mutations. The process of mutagenesis is random, or nearly so, and is modelled by movement between points on this plane as the genotype of an individual or population changes. The Y axis is the fitness of each of those genotypes, and is determined by the interaction between the phenotypes and the abiotic/ biotic environment. Beneficial phenotypes are fitness peaks on the landscape, while deleterious phenotypes are valleys. The genotype-phenotype-fitness map is difficult to predict because many non-additive processes (like epistasis) and emergent phenomena occur that cannot be predicted by simply 'summing up the parts' or adding the effect of indivdual variants. Regdarless of the topology of this landscape, natural selection (or the 'survival of the fittest' principle) will work to maximize fitness, which is represented by climbing towards peaks. Finally, genetic drift causes differential propagation of genotypes independent of their fitness, and introduces 'noise' or stochasticity. The overarching goal of this project is two-fold: Can these major evolutionary processes be captured in a computer simulation? Does this simultion recapitulate some expected evolutionary outcomes? picocell is an in-silico simualtion that combines a protein large language model, probabilistic models of mutation and drift, with a rule-based approach of fitness-maximizing natural selection. picocell has several flexible parameters that can be changed to observe different outcomes. Please see the methods to understand how this is implemented, or the the code page to learn to use it.","title":"Introduction"},{"location":"introduction/#introduction","text":"Physicists have spent a lot of time looking for a grand theory to unify the discipline; biologists were gifted one with the theory of evolution in the 19th century. I don\u2019t think evolution alone has the explanatory power to describe all biological processes, but rather that evolution is the framework within which all of biology is contextualised. It is omnipresent, from viruses to elephants to mosses, and it is causally responsible for the 'endless forms most beautiful and most wonderful'. Evolution is a complex phenomenon, and often manifests patterns that seem to be in conflict with each other. Evolution generates both convergence and divergence in form and function. Sometimes, it is highly predictable and repeatable; other times it is idiosyncratic. Inspite of this, evolution can be broken down to a few key components, and these components are best explained through the metaphor of the 'fitness landscape'. The XY plane is a low-dimensional representation of 'genotypic space', where each point in the plane represents a unique set of alleles or mutations. The process of mutagenesis is random, or nearly so, and is modelled by movement between points on this plane as the genotype of an individual or population changes. The Y axis is the fitness of each of those genotypes, and is determined by the interaction between the phenotypes and the abiotic/ biotic environment. Beneficial phenotypes are fitness peaks on the landscape, while deleterious phenotypes are valleys. The genotype-phenotype-fitness map is difficult to predict because many non-additive processes (like epistasis) and emergent phenomena occur that cannot be predicted by simply 'summing up the parts' or adding the effect of indivdual variants. Regdarless of the topology of this landscape, natural selection (or the 'survival of the fittest' principle) will work to maximize fitness, which is represented by climbing towards peaks. Finally, genetic drift causes differential propagation of genotypes independent of their fitness, and introduces 'noise' or stochasticity. The overarching goal of this project is two-fold: Can these major evolutionary processes be captured in a computer simulation? Does this simultion recapitulate some expected evolutionary outcomes? picocell is an in-silico simualtion that combines a protein large language model, probabilistic models of mutation and drift, with a rule-based approach of fitness-maximizing natural selection. picocell has several flexible parameters that can be changed to observe different outcomes. Please see the methods to understand how this is implemented, or the the code page to learn to use it.","title":"Introduction"},{"location":"methods/","text":"Methods picocell 's workflow is outlined in the following schematic: Set up Picocell is set up as a series of decision trees that are applied to each cell at each generation. Each cell is implemented as Python object with the following attributes: class cell: \"\"\" A class that represents a cell \"\"\" def __init__(self, id=0, dna_sequence=\"\",aa_sequence=\"\",fitness=0.0,mutation_rate=0.0, generation=0, death=0): self.id = id # each cell has an integer ID number to keep track of it self.dna_sequence = dna_sequence # a string that represents the DNA sequence self.aa_sequence = aa_sequence # a string that represents the DNA sequence self.fitness = fitness # float that represents the fitness of the cell, based on its sequence self.mutation_rate = mutation_rate # a float that is the per-base per-generation mutation rate self.generation = generation # an int indicating the generation in which the cell is born self.death = death # an int indicating the generation in which the cell dies Each cell has the DNA sequence corresponding to the coding sequence of a Cas12f protein from Acidibacillus sulfuroxidans i.e. the whole genome is a single ORF. In addition to these cellular attributes, there are two variables associated with each simulation: the level of genetic drift \\(d\\) and the presence/absence of natural selection. Genetic Drift The genetic drift level \\(d\\) represents the probability that a cell is killed in that generation. This probability is constant across the generations, and is independent of the sequence or the fitness of the cell. \\[P(\\text{death}) = d\\] \\[P(\\text{live}) = 1-d\\] Natural Selection Each cell has a sequence, and each sequence has a corresponding 'fitness'. In the context of the Cas12f protein, this is the genome editing efficiency, normalized by the activity of the wildtype sequence. The fitness of the wildtype sequence is 1, and mutants with greater editing efficiency than the wildtype have a fitness of >1 while those with lower editing efficiency have a fitness value <1. In order to use the fitness to inform the growth of the cells, each cell has a probability of dividing that is equal to their fitness \\(f\\) scaled by a factor \\(\\kappa\\) . \\[P(\\text{divide}) = \\kappa f\\] \\[P(\\text{no division}) = 1 - \\kappa f\\] Mutation Once a cell 'decides' to divide, the opportunity for mutations to occur arises. Each cell has a mutation rate \\(\\mu\\) which is defined as the per base per generation probability of generating a mutation. Formally, \\[ \\text{Let } S \\text{ denote the sequence of the parental cell, where } S=\\{B_1,B_2..B_n\\} \\text{ is a sequence of N bases}\\] \\[ \\forall B_i \\in S, P(B_i\\rightarrow B_i')=\\mu \\] \\[ \\text{where } B_i \\neq B_i' \\text{ and } B_i \\text{ represents the wildtype base and } B_i' \\text{ represents the mutant base}\\] Each base has an equal chance to mutating to any other base, i.e. there is no mutational bias. Genotype-Phenotype-Fitness Mapping After a cell divides, there are four possible outcomes for the child cell: No mutation: The child cell has the same sequence and fitness as the parental cell Synonymous mutation: The child cell has a different DNA sequence, but the same fitness as the parental cell (assuming that all synonmymous mutations are silent) Nonsense mutation: As a rule, if a premature stop codon is introduced, then this is considered a lethal mutation and the child cell is killed. Nonsynonymous mutation: The DNA and amino acid sequence has changed, and the fitness must be recomputed for this mutation. If the nonsynonymous mutation is present in the DMS dataset for the Cas12f protein, then the fitness value is fetched from the table. Otherwise, the embeddings are extracted for the new sequence using ESM-1b, and the embeddings are fed to a random forest regressor to map to a fitness value. For more information about how this regressor was trained, please see the code page . For the ORF of length \\(M\\) amino acids, ESM generates an embedding matrix \\(E \\in \\mathbb{R}^{M \\times D}\\) where \\(D\\) is the dimensionality of the embedding space. The embeddings are averaged across all amino acids to generate a vector representation \\(e \\in \\mathbb{R}^{D}\\) for the protein. Training the regressor on the DMS dataset with a random 80:20 train:test split yielded an \\(R^2\\) ~ \\(0.35\\) . Cross-validation to tune the hyperparameters (in this case the number of the trees in the forest) may have yielded better results. For the purposes of the project, the default value of 100 trees was used. After recomputing the fitness, the newly born children cells join their parents to become parent cells for the next generation and the simulation continues for the specified number of generation.","title":"Methods"},{"location":"methods/#methods","text":"picocell 's workflow is outlined in the following schematic:","title":"Methods"},{"location":"methods/#set-up","text":"Picocell is set up as a series of decision trees that are applied to each cell at each generation. Each cell is implemented as Python object with the following attributes: class cell: \"\"\" A class that represents a cell \"\"\" def __init__(self, id=0, dna_sequence=\"\",aa_sequence=\"\",fitness=0.0,mutation_rate=0.0, generation=0, death=0): self.id = id # each cell has an integer ID number to keep track of it self.dna_sequence = dna_sequence # a string that represents the DNA sequence self.aa_sequence = aa_sequence # a string that represents the DNA sequence self.fitness = fitness # float that represents the fitness of the cell, based on its sequence self.mutation_rate = mutation_rate # a float that is the per-base per-generation mutation rate self.generation = generation # an int indicating the generation in which the cell is born self.death = death # an int indicating the generation in which the cell dies Each cell has the DNA sequence corresponding to the coding sequence of a Cas12f protein from Acidibacillus sulfuroxidans i.e. the whole genome is a single ORF. In addition to these cellular attributes, there are two variables associated with each simulation: the level of genetic drift \\(d\\) and the presence/absence of natural selection.","title":"Set up"},{"location":"methods/#genetic-drift","text":"The genetic drift level \\(d\\) represents the probability that a cell is killed in that generation. This probability is constant across the generations, and is independent of the sequence or the fitness of the cell. \\[P(\\text{death}) = d\\] \\[P(\\text{live}) = 1-d\\]","title":"Genetic Drift"},{"location":"methods/#natural-selection","text":"Each cell has a sequence, and each sequence has a corresponding 'fitness'. In the context of the Cas12f protein, this is the genome editing efficiency, normalized by the activity of the wildtype sequence. The fitness of the wildtype sequence is 1, and mutants with greater editing efficiency than the wildtype have a fitness of >1 while those with lower editing efficiency have a fitness value <1. In order to use the fitness to inform the growth of the cells, each cell has a probability of dividing that is equal to their fitness \\(f\\) scaled by a factor \\(\\kappa\\) . \\[P(\\text{divide}) = \\kappa f\\] \\[P(\\text{no division}) = 1 - \\kappa f\\]","title":"Natural Selection"},{"location":"methods/#mutation","text":"Once a cell 'decides' to divide, the opportunity for mutations to occur arises. Each cell has a mutation rate \\(\\mu\\) which is defined as the per base per generation probability of generating a mutation. Formally, \\[ \\text{Let } S \\text{ denote the sequence of the parental cell, where } S=\\{B_1,B_2..B_n\\} \\text{ is a sequence of N bases}\\] \\[ \\forall B_i \\in S, P(B_i\\rightarrow B_i')=\\mu \\] \\[ \\text{where } B_i \\neq B_i' \\text{ and } B_i \\text{ represents the wildtype base and } B_i' \\text{ represents the mutant base}\\] Each base has an equal chance to mutating to any other base, i.e. there is no mutational bias.","title":"Mutation"},{"location":"methods/#genotype-phenotype-fitness-mapping","text":"After a cell divides, there are four possible outcomes for the child cell: No mutation: The child cell has the same sequence and fitness as the parental cell Synonymous mutation: The child cell has a different DNA sequence, but the same fitness as the parental cell (assuming that all synonmymous mutations are silent) Nonsense mutation: As a rule, if a premature stop codon is introduced, then this is considered a lethal mutation and the child cell is killed. Nonsynonymous mutation: The DNA and amino acid sequence has changed, and the fitness must be recomputed for this mutation. If the nonsynonymous mutation is present in the DMS dataset for the Cas12f protein, then the fitness value is fetched from the table. Otherwise, the embeddings are extracted for the new sequence using ESM-1b, and the embeddings are fed to a random forest regressor to map to a fitness value. For more information about how this regressor was trained, please see the code page . For the ORF of length \\(M\\) amino acids, ESM generates an embedding matrix \\(E \\in \\mathbb{R}^{M \\times D}\\) where \\(D\\) is the dimensionality of the embedding space. The embeddings are averaged across all amino acids to generate a vector representation \\(e \\in \\mathbb{R}^{D}\\) for the protein. Training the regressor on the DMS dataset with a random 80:20 train:test split yielded an \\(R^2\\) ~ \\(0.35\\) . Cross-validation to tune the hyperparameters (in this case the number of the trees in the forest) may have yielded better results. For the purposes of the project, the default value of 100 trees was used. After recomputing the fitness, the newly born children cells join their parents to become parent cells for the next generation and the simulation continues for the specified number of generation.","title":"Genotype-Phenotype-Fitness Mapping"},{"location":"refs/","text":"References Hino, T. et al. (2023). An AsCas12f-based compact genome-editing tool derived by deep mutational scanning and structural analysis. Cell, 186(22), 4920\u20134935.e23. https://doi.org/10.1016/j.cell.2023.08.031 Kaiyi Jiang et al. (2025). Rapid in silico directed evolution by a protein language model with EVOLVEpro. Science. DOI:10.1126/science.adr6006 Roshan Rao et al. (2021). MSA Transformer. bioRxiv. doi: https://doi.org/10.1101/2021.02.12.430858 Wickham H (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. ISBN 978-3-319-24277-4 Pedregosa et al. (2011) Scikit-learn: Machine Learning in Python, JMLR 12, pp. 2825-2830, 2011. Wilke C (2024). cowplot: Streamlined Plot Theme and Plot Annotations for 'ggplot2'. R package version 1.1.3, https://wilkelab.org/cowplot/. Special thanks to: Dr. Marcotte and Zoya Ansari Authors of EvolvePro for making their code open source Creators of ESM for making the model weights open Members of the Wilke Lab and BioML Society at UT Austin for introducing me to PLMs","title":"References"},{"location":"refs/#references","text":"Hino, T. et al. (2023). An AsCas12f-based compact genome-editing tool derived by deep mutational scanning and structural analysis. Cell, 186(22), 4920\u20134935.e23. https://doi.org/10.1016/j.cell.2023.08.031 Kaiyi Jiang et al. (2025). Rapid in silico directed evolution by a protein language model with EVOLVEpro. Science. DOI:10.1126/science.adr6006 Roshan Rao et al. (2021). MSA Transformer. bioRxiv. doi: https://doi.org/10.1101/2021.02.12.430858 Wickham H (2016). ggplot2: Elegant Graphics for Data Analysis. Springer-Verlag New York. ISBN 978-3-319-24277-4 Pedregosa et al. (2011) Scikit-learn: Machine Learning in Python, JMLR 12, pp. 2825-2830, 2011. Wilke C (2024). cowplot: Streamlined Plot Theme and Plot Annotations for 'ggplot2'. R package version 1.1.3, https://wilkelab.org/cowplot/. Special thanks to: Dr. Marcotte and Zoya Ansari Authors of EvolvePro for making their code open source Creators of ESM for making the model weights open Members of the Wilke Lab and BioML Society at UT Austin for introducing me to PLMs","title":"References"},{"location":"results/","text":"Results To address the second goal of this project, I ran several simulations where I varied the different parameters (mutation rate, strength of genetic drift, presence of selection) to determine if picocell recapitulates some expected behaviour of the general evolutionary process. All simulations were run for a total of 20 generations, although some terminated prior to this end point if all cells prematurely died. Results were plotted in R with ggplot . High mutation rate is deleterious and causes fitness decline Mutations are the primary source of genotypic novelty, and provide the raw material necessary for evolution and adaptation. However high mutation rates can cause a decline in the fitness of a population by increasing the rate of deleterious mutations. I predicted that within the time frame of the simulation, the mean fitness of the cells at the final time point declines with increasing mutation rates. Fig: Mean population fitness at 20 generations for simulations run with different mutation rates. Rates indicated are per base per generation. For mutation rates between \\(10^{-8} - 10^{-4}\\) , the fitness remains at or close to the wildtype fitness. This is because the mutation rate is so low, and the coding sequence is short, that few to no mutations arise, and all of the offspring retain the parental wildtype fitness. For mutation rates \\(>10^{-4}\\) , the rate is high enough to see multiple mutations arise over the course of the simulation. Indeed, we do observe falling population fitness under very high mutation rates. Furthermore, we also expect that under conditions of high mutation rate, a greater proportion of the cells born in the experiment will have lethal mutations. Indeed, we observe this pattern. Fig: Proportion of cells with a lethal mutation, for simulations run with different mutation rates. Finally, if we plot the trajectory of the fitness of the population over time, we can see that the decline in fitness occurs more rapidly with higher mutation rates. Fig: Mean population fitness over time, for simulations run with different mutation rates. Rates shown are log10 rates. The decline does perfectly correspond with increasing mutation rates, as these lines are only represent a single simulation and randomness influences these fitness trajectories. The pattern would hold more strongly if the trajectories were computed from the mean of several runs. Furthermore, because the population starts out with high fitness (i.e. already at a fitness peak), most mutations are deleterious, and we do not observe any of the populations increasing fitness above the ancestral value. Natural selection has a compounding effect, and it is possible that over more generations, rare beneficial variants will have enough time to take over the population and increase the mean value above the wildtype level. However for this short duration, I did not observe this. Genetic drift reduces population fitness Genetic drift causes the differential persistence of population members, regardless of their fitness. Under conditions of strong genetic drift, we expect that the mean population fitness should reduce. In these simulations, genetic drift is implemented by randomly killing each cells at each generations with probability \\(P(death) = d\\) . Fig: Mean population fitness at 20 generations, for different levels of genetic drift in the simulation. Mean fitness declines when drift increases from 0.01 to 0.05. However, fitness is 0 for drift >0.1. This is because at this level of drift, the probability of dying randomly is comparable or greater than the probability of reproducing. In these simulations, no cells survive to the end, which is why fitness is 0. Natural selection increases population fitness picocell can be run in two modes: with and without selection. We predict that in the absence of natural selection (i.e. all genotypes have an equal chance of reproducing, independent of their fitness), the mean population fitness will be lower. Fig: Mean fitness at the final time point, for a simulation run with and without natural selection.","title":"Results"},{"location":"results/#results","text":"To address the second goal of this project, I ran several simulations where I varied the different parameters (mutation rate, strength of genetic drift, presence of selection) to determine if picocell recapitulates some expected behaviour of the general evolutionary process. All simulations were run for a total of 20 generations, although some terminated prior to this end point if all cells prematurely died. Results were plotted in R with ggplot .","title":"Results"},{"location":"results/#high-mutation-rate-is-deleterious-and-causes-fitness-decline","text":"Mutations are the primary source of genotypic novelty, and provide the raw material necessary for evolution and adaptation. However high mutation rates can cause a decline in the fitness of a population by increasing the rate of deleterious mutations. I predicted that within the time frame of the simulation, the mean fitness of the cells at the final time point declines with increasing mutation rates. Fig: Mean population fitness at 20 generations for simulations run with different mutation rates. Rates indicated are per base per generation. For mutation rates between \\(10^{-8} - 10^{-4}\\) , the fitness remains at or close to the wildtype fitness. This is because the mutation rate is so low, and the coding sequence is short, that few to no mutations arise, and all of the offspring retain the parental wildtype fitness. For mutation rates \\(>10^{-4}\\) , the rate is high enough to see multiple mutations arise over the course of the simulation. Indeed, we do observe falling population fitness under very high mutation rates. Furthermore, we also expect that under conditions of high mutation rate, a greater proportion of the cells born in the experiment will have lethal mutations. Indeed, we observe this pattern. Fig: Proportion of cells with a lethal mutation, for simulations run with different mutation rates. Finally, if we plot the trajectory of the fitness of the population over time, we can see that the decline in fitness occurs more rapidly with higher mutation rates. Fig: Mean population fitness over time, for simulations run with different mutation rates. Rates shown are log10 rates. The decline does perfectly correspond with increasing mutation rates, as these lines are only represent a single simulation and randomness influences these fitness trajectories. The pattern would hold more strongly if the trajectories were computed from the mean of several runs. Furthermore, because the population starts out with high fitness (i.e. already at a fitness peak), most mutations are deleterious, and we do not observe any of the populations increasing fitness above the ancestral value. Natural selection has a compounding effect, and it is possible that over more generations, rare beneficial variants will have enough time to take over the population and increase the mean value above the wildtype level. However for this short duration, I did not observe this.","title":"High mutation rate is deleterious and causes fitness decline"},{"location":"results/#genetic-drift-reduces-population-fitness","text":"Genetic drift causes the differential persistence of population members, regardless of their fitness. Under conditions of strong genetic drift, we expect that the mean population fitness should reduce. In these simulations, genetic drift is implemented by randomly killing each cells at each generations with probability \\(P(death) = d\\) . Fig: Mean population fitness at 20 generations, for different levels of genetic drift in the simulation. Mean fitness declines when drift increases from 0.01 to 0.05. However, fitness is 0 for drift >0.1. This is because at this level of drift, the probability of dying randomly is comparable or greater than the probability of reproducing. In these simulations, no cells survive to the end, which is why fitness is 0.","title":"Genetic drift reduces population fitness"},{"location":"results/#natural-selection-increases-population-fitness","text":"picocell can be run in two modes: with and without selection. We predict that in the absence of natural selection (i.e. all genotypes have an equal chance of reproducing, independent of their fitness), the mean population fitness will be lower. Fig: Mean fitness at the final time point, for a simulation run with and without natural selection.","title":"Natural selection increases population fitness"}]}